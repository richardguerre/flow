"use strict";const $=e=>({plugin:e}),O="account-tokens",p="connected-calendars",R=$(e=>{const _=`${e.pluginSlug}-get-events`,T=`${e.pluginSlug}-calendars-sync`,S=`${e.pluginSlug}-upsert-item-from-event`,A=`${e.pluginSlug}-process-events-webhook`,j=`flow-${e.pluginSlug}-events-webhook`,I=async()=>{const c=await e.store.getPluginItem(O);if(!c)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});return c.value},v=async c=>{const t=(c.accountsTokens??await I())[c.account];if(!t)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});if(e.dayjs().isAfter(t.expires_at)){const a=await fetch("https://google-calendar-api-flow-dev.vercel.app/api/auth/refresh?refresh_token="+t.refresh_token);if(!a.ok)throw new e.GraphQLError("Could not refresh token.",{extensions:{code:"COULD_NOT_REFRESH_TOKEN",userFriendlyMessage:"Could not connect to Google Calendar. Please try connecting your account(s) again."}});const n=await a.json(),d={...n,refresh_token:t.refresh_token,expires_at:e.dayjs().add((n.expires_in??10)-10,"seconds").toISOString()};return await e.store.setSecretItem(O,{...c.accountsTokens,[c.account]:d}),d}return t};return{onRequest:async c=>{var l,t;if(c.path==="/auth")return Response.redirect(`https://google-calendar-api-flow-dev.vercel.app/api/auth?api_endpoint=${e.serverOrigin}/api/plugin/${e.pluginSlug}/auth/callback`);if(c.path==="/auth/callback"&&c.request.method==="POST"){const a=await e.store.getPluginItem(O),n=c.body,d={...n,refresh_token:n.refresh_token??((l=a==null?void 0:a.value)==null?void 0:l[n.email].refresh_token),expires_at:e.dayjs().add((n.expires_in??10)-10,"seconds").toISOString()};return"expires_in"in d&&delete d.expires_in,await e.store.setSecretItem(O,{...(a==null?void 0:a.value)??{},[d.email]:d}),new Response}else if(c.path==="/events/webhook"&&c.request.method==="POST"){const a=c.headers["x-goog-resource-uri"],n=(t=a.match(/\/calendars\/(.*)\/events/))==null?void 0:t[1];if(!n)return console.log("❌ Could not find calendarId in x-goog-resource-uri header",a),new Response;const d=decodeURIComponent(n);return await e.pgBoss.send(A,{calendarId:d}),new Response}},operations:{calendars:async()=>{const c=await I(),l=[];for(const t of Object.keys(c)){const a=await v({account:t,accountsTokens:c}).catch(r=>({error:r}));if("error"in a){l.push({account:t,authError:a.error.extensions.userFriendlyMessage??a.error.message});continue}const n=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${a.access_token}`}}).then(r=>r.json()).then(r=>r.items),d=await e.store.getPluginItem(p).then(r=>{var o;return new Set(((o=r==null?void 0:r.value)==null?void 0:o.map(u=>u.calendarId))??[])});l.push({account:t,calendars:(n==null?void 0:n.map(r=>({...r,connected:d.has(r.id??"")})))??[]})}return{data:l}},connectCalendars:async c=>{const l=await I(),t=await e.store.getPluginItem(p).then(n=>{var d;return new Map(((d=n==null?void 0:n.value)==null?void 0:d.map(r=>[r.calendarId,r]))??[])}),a=[];for(const n of Object.keys(l)){const d=await v({account:n,accountsTokens:l}),r=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${d.access_token}`}}).then(o=>o.json()).then(o=>o.items);for(const o of c.calendarIds){if(t.has(o)||!(r!=null&&r.some(g=>g.id===o)))continue;await e.pgBoss.send(_,{calendarId:o,days:7});const u=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${o}/events/watch`,{method:"POST",headers:{Authorization:`Bearer ${d.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({id:j,type:"web_hook",address:`${e.serverOrigin}/api/plugin/${e.pluginSlug}/events/webhook`})}).then(g=>g.json());console.log("✔ Set up webhook for calendar",o),t.set(o,{account:n,calendarId:o,lastSyncedAt:e.dayjs().toISOString(),channelId:u.id??j,resourceId:u.resourceId,expiresAt:e.dayjs(u.expiration??0).toISOString()})}for(const o of r??[]){if(!o.id||c.calendarIds.includes(o.id))continue;const u=t.get(o.id);u&&(await fetch("https://www.googleapis.com/calendar/v3/channels/stop",{method:"POST",headers:{Authorization:`Bearer ${d.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({id:u.channelId,resourceId:u.resourceId})}),console.log("✔ Removed webhook for calendar",o.id),t.delete(o.id))}a.push({account:n,calendars:(r==null?void 0:r.map(o=>({...o,connected:t.has(o.id??"")})))??[]})}return await e.store.setItem(p,Array.from(t.values())),await e.pgBoss.schedule(T,"0 3 */3 * *",{calendarIds:c.calendarIds}),console.log("✔ Scheduled calendars sync job"),{operationName:"calendars",data:a}},refreshEvents:async c=>{const l=await e.store.getPluginItem(p).then(t=>(t==null?void 0:t.value.map(a=>a.calendarId))??[]);return await e.pgBoss.send(T,{calendarIds:l??[],days:c.days??7}),{data:"Job sent to refresh events."}}},handlePgBossWork:c=>[c(S,{batchSize:5},async l=>{var t,a,n,d,r,o,u,g;for(const i of l){const s=i.data,w=await e.prisma.item.findFirst({where:{pluginDatas:{some:{originalId:s.id,pluginSlug:e.pluginSlug}}},include:{pluginDatas:{where:{originalId:s.id,pluginSlug:e.pluginSlug},select:{id:!0}},tasks:{select:{id:!0,pluginDatas:{select:{id:!0},take:1,orderBy:{createdAt:"asc"}}},take:1,orderBy:{createdAt:"asc"}}}});if(!w&&s.status==="cancelled")continue;if(!w&&["outOfOffice","workingLocation"].includes(s.eventType??"default"))continue;const b=await e.getUsersTimezone()??"Etc/GMT-0",h=w==null?void 0:w.tasks[0],B=!!((t=s.start)!=null&&t.date),f=(a=s.start)!=null&&a.date?e.dayjs(s.start.date).startOf("day"):(n=s.start)!=null&&n.dateTime?e.dayjs(s.start.dateTime):e.dayjs(),k=(d=s.end)!=null&&d.date?e.dayjs(s.end.date).endOf("day"):(r=s.end)!=null&&r.dateTime?e.dayjs(s.end.dateTime):f.add(1,"millisecond"),D=k.isBefore(e.dayjs()),N=f.tz(b).utc(!0).toISOString(),E={title:s.summary??"No title",color:s.calendarColor?e.getNearestItemColor(s.calendarColor):null,isAllDay:B,scheduledAt:f.toISOString(),durationInMinutes:B?null:Math.abs(e.dayjs(f).diff(k,"minute")),isRelevant:s.status!=="cancelled",inboxPoints:s.status==="tentative"?10:null},m={eventType:s.eventType,status:s.status,htmlLink:s.htmlLink,numOfAttendees:((o=s.attendees)==null?void 0:o.length)??0,conferenceData:s.conferenceData,hexBackgroundColor:s.calendarColor},y={...s,...m},C={title:E.title,completedAt:D?k.toISOString():null,status:s.status==="cancelled"?"CANCELED":D?"DONE":"TODO",day:{connectOrCreate:{where:{date:N},create:{date:N,tasksOrder:h!=null&&h.id?[h.id]:[]}}}};w?await e.prisma.item.update({where:{id:w.id},data:{...E,pluginDatas:{update:{where:{id:(u=w.pluginDatas[0])==null?void 0:u.id},data:{min:m,full:y}}},tasks:{upsert:{where:{id:h==null?void 0:h.id},update:{...C,pluginDatas:{update:{where:{id:(g=h==null?void 0:h.pluginDatas[0])==null?void 0:g.id},data:{min:m,full:y}}}},create:{...C,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:s.id,min:m,full:y}}}}}}}):await e.prisma.item.create({data:{...E,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:s.id,min:m,full:y}},tasks:{create:{...C,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:s.id,min:m,full:y}}}}}}),await e.pgBoss.sendAfter(S,{...s},{},k.toDate()),console.log("✔ Upserted item from event",s.summary,f==null?void 0:f.toISOString())}}),c(_,async l=>{var n,d;const t=l.data,a=await I();for(const r of Object.keys(a)){const o=await v({account:r,accountsTokens:a}),u=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}`,{headers:{Authorization:`Bearer ${o.access_token}`}}).then(i=>i.json()),g=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}/events?timeMin=${encodeURIComponent(e.dayjs().startOf("day").toISOString())}&timeMax=${encodeURIComponent(e.dayjs().add(t.days??7,"day").toISOString())}&singleEvents=true&orderBy=startTime`,{headers:{Authorization:`Bearer ${o.access_token}`}}).then(i=>i.json());console.log(((n=g.items)==null?void 0:n.length)??0,((d=g.items)==null?void 0:d.length)===1?"event":"events","to process from initial sync of calendar",t.calendarId);for(const i of g.items??[])await e.pgBoss.send(S,{...i,calendarColor:u.backgroundColor??null})}}),c(A,async l=>{var u,g;const t=l.data,a=await e.store.getPluginItem(p).then(i=>(i==null?void 0:i.value)??[]),n=a.find(i=>i.calendarId===t.calendarId);if(!n){console.log("❌ Could not find calendar to process",t.calendarId);return}const d=await v({account:n.account}),r=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}`,{headers:{Authorization:`Bearer ${d.access_token}`}}).then(i=>i.json()),o=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}/events?updatedMin=${encodeURIComponent(e.dayjs(n.lastSyncedAt).toISOString())}&singleEvents=true&orderBy=updated`,{headers:{Authorization:`Bearer ${d.access_token}`}}).then(i=>i.json());console.log(((u=o.items)==null?void 0:u.length)??0,((g=o.items)==null?void 0:g.length)===1?"event":"events","to process from webhook of calendar",t.calendarId);for(const i of o.items??[])await e.pgBoss.send(S,{...i,calendarColor:r.backgroundColor??null});await e.store.setItem(p,[...a.filter(i=>i.calendarId!==t.calendarId),{...n,lastSyncedAt:e.dayjs().toISOString()}])}),c(T,async l=>{const t=l.data;for(const a of t.calendarIds)await e.pgBoss.send(_,{calendarId:a,days:t.days??7})})]}});module.exports=R;
