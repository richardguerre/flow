"use strict";const M=e=>({plugin:e}),k="account-tokens",m="connected-calendars",P=M(e=>{const O=`${e.pluginSlug}-get-events`,p=`${e.pluginSlug}-calendars-sync`,S=`${e.pluginSlug}-upsert-item-from-event`,C=`${e.pluginSlug}-process-events-webhook`,v=`${e.pluginSlug}-cleanup-events`,D=`flow-${e.pluginSlug}-events-webhook`,$=[p],x=[O,p,S,C,v],T=async()=>{const t=await e.store.getPluginItem(k);if(!t)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});return t.value},_=async t=>{const a=(t.accountsTokens??await T())[t.account];if(!a)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});if(e.dayjs().isAfter(a.expires_at)){const o=await fetch("https://google-calendar-api-flow-dev.vercel.app/api/auth/refresh?refresh_token="+a.refresh_token);if(!o.ok){const n=e.dayjs().utc(!0).startOf("day").toDate();throw await e.prisma.task.findFirst({where:{date:{gte:n},pluginDatas:{some:{originalId:"not-authenticated",pluginSlug:e.pluginSlug}}}})||await e.prisma.task.create({data:{title:'<a href="/settings/plugin/google-calendar">Re-connect</a> your Google Calendar account. There was an issue with the connection.',pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:"not-authenticated",min:{},full:{}}},day:{connectOrCreate:{where:{date:n},create:{date:n,tasksOrder:[]}}}}}),await e.pgBoss.send(v,{}),new e.GraphQLError("Could not refresh token.",{extensions:{code:"COULD_NOT_REFRESH_TOKEN",userFriendlyMessage:"Could not connect to Google Calendar. Please try connecting your account(s) again."}})}const r=await o.json(),i={...r,refresh_token:a.refresh_token,expires_at:e.dayjs().add((r.expires_in??10)-10,"seconds").toISOString()};return await e.store.setSecretItem(k,{...t.accountsTokens,[t.account]:i}),i}return a};return{onRequest:async t=>{var d,a;if(t.path==="/auth")return Response.redirect(`https://google-calendar-api-flow-dev.vercel.app/api/auth?api_endpoint=${e.serverOrigin}/api/plugin/${e.pluginSlug}/auth/callback`);if(t.path==="/auth/callback"&&t.request.method==="POST"){const o=await e.store.getPluginItem(k),r=t.body,i={...r,refresh_token:r.refresh_token??((d=o==null?void 0:o.value)==null?void 0:d[r.email].refresh_token),expires_at:e.dayjs().add((r.expires_in??10)-10,"seconds").toISOString()};return"expires_in"in i&&delete i.expires_in,await e.store.setSecretItem(k,{...(o==null?void 0:o.value)??{},[i.email]:i}),new Response}else if(t.path==="/events/webhook"&&t.request.method==="POST"){const o=t.headers["x-goog-resource-uri"],r=(a=o.match(/\/calendars\/(.*)\/events/))==null?void 0:a[1];if(!r)return console.log("❌ Could not find calendarId in x-goog-resource-uri header",o),new Response;const i=decodeURIComponent(r);return await e.pgBoss.send(C,{calendarId:i}),new Response}},operations:{calendars:async()=>{const t=await T(),d=[];for(const a of Object.keys(t)){const o=await _({account:a,accountsTokens:t}).catch(n=>({error:n}));if("error"in o){d.push({account:a,authError:o.error.extensions.userFriendlyMessage??o.error.message});continue}const r=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${o.access_token}`}}).then(n=>n.json()).then(n=>n.items),i=await e.store.getPluginItem(m).then(n=>{var s;return new Set(((s=n==null?void 0:n.value)==null?void 0:s.map(u=>u.calendarId))??[])});d.push({account:a,calendars:(r==null?void 0:r.map(n=>({...n,connected:i.has(n.id??"")})))??[]})}return{data:d}},connectCalendars:async t=>{const d=await T(),a=await e.store.getPluginItem(m).then(r=>{var i;return new Map(((i=r==null?void 0:r.value)==null?void 0:i.map(n=>[n.calendarId,n]))??[])}),o=[];for(const r of Object.keys(d)){const i=await _({account:r,accountsTokens:d}),n=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${i.access_token}`}}).then(s=>s.json()).then(s=>s.items);for(const s of t.calendarIds){if(a.has(s)||!(n!=null&&n.some(g=>g.id===s)))continue;await e.pgBoss.send(O,{calendarId:s,days:7});const u=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${s}/events/watch`,{method:"POST",headers:{Authorization:`Bearer ${i.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({id:D,type:"web_hook",address:`${e.serverOrigin}/api/plugin/${e.pluginSlug}/events/webhook`})}).then(g=>g.json());console.log("✔ Set up webhook for calendar",s),a.set(s,{account:r,calendarId:s,lastSyncedAt:e.dayjs().toISOString(),channelId:u.id??D,resourceId:u.resourceId,expiresAt:e.dayjs(u.expiration??0).toISOString()})}for(const s of n??[]){if(!s.id||t.calendarIds.includes(s.id))continue;const u=a.get(s.id);u&&(await fetch("https://www.googleapis.com/calendar/v3/channels/stop",{method:"POST",headers:{Authorization:`Bearer ${i.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({id:u.channelId,resourceId:u.resourceId})}),console.log("✔ Removed webhook for calendar",s.id),a.delete(s.id))}o.push({account:r,calendars:(n==null?void 0:n.map(s=>({...s,connected:a.has(s.id??"")})))??[]})}return await e.store.setItem(m,Array.from(a.values())),await e.pgBoss.schedule(p,"0 3 */3 * *",{calendarIds:t.calendarIds}),console.log("✔ Scheduled calendars sync job"),{operationName:"calendars",data:o}},refreshEvents:async t=>{const d=await e.store.getPluginItem(m).then(a=>(a==null?void 0:a.value.map(o=>o.calendarId))??[]);return await e.pgBoss.send(p,{calendarIds:d??[],days:t.days??7}),{data:"Job sent to refresh events."}}},handlePgBossWork:t=>[t(S,{batchSize:5},async d=>{var a,o,r,i,n,s,u,g;for(const l of d){const c=l.data,w=await e.prisma.item.findFirst({where:{pluginDatas:{some:{originalId:c.id,pluginSlug:e.pluginSlug}}},include:{pluginDatas:{where:{originalId:c.id,pluginSlug:e.pluginSlug},select:{id:!0}},tasks:{select:{id:!0,pluginDatas:{select:{id:!0},take:1,orderBy:{createdAt:"asc"}}},take:1,orderBy:{createdAt:"asc"}}}});if(!w&&c.status==="cancelled")continue;if(!w&&["outOfOffice","workingLocation"].includes(c.eventType??"default"))continue;const R=await e.getUsersTimezone()??"Etc/GMT-0",h=w==null?void 0:w.tasks[0],B=!!((a=c.start)!=null&&a.date),f=(o=c.start)!=null&&o.date?e.dayjs(c.start.date).startOf("day"):(r=c.start)!=null&&r.dateTime?e.dayjs(c.start.dateTime):e.dayjs(),E=(i=c.end)!=null&&i.date?e.dayjs(c.end.date).endOf("day"):(n=c.end)!=null&&n.dateTime?e.dayjs(c.end.dateTime):f.add(1,"millisecond"),N=E.isBefore(e.dayjs()),b=f.tz(R).utc(!0).toISOString(),A={title:c.summary??"No title",color:c.calendarColor?e.getNearestItemColor(c.calendarColor):null,isAllDay:B,scheduledAt:f.toISOString(),durationInMinutes:B?null:Math.abs(e.dayjs(f).diff(E,"minute")),isRelevant:c.status!=="cancelled",inboxPoints:c.status==="tentative"?10:null},y={eventType:c.eventType,status:c.status,htmlLink:c.htmlLink,numOfAttendees:((s=c.attendees)==null?void 0:s.length)??0,conferenceData:c.conferenceData,hexBackgroundColor:c.calendarColor},I={...c,...y},j={title:A.title,completedAt:N?E.toISOString():null,status:c.status==="cancelled"?"CANCELED":N?"DONE":"TODO",day:{connectOrCreate:{where:{date:b},create:{date:b,tasksOrder:h!=null&&h.id?[h.id]:[]}}}};w?await e.prisma.item.update({where:{id:w.id},data:{...A,pluginDatas:{update:{where:{id:(u=w.pluginDatas[0])==null?void 0:u.id},data:{min:y,full:I}}},tasks:{upsert:{where:{id:h==null?void 0:h.id},update:{...j,pluginDatas:{update:{where:{id:(g=h==null?void 0:h.pluginDatas[0])==null?void 0:g.id},data:{min:y,full:I}}}},create:{...j,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:c.id,min:y,full:I}}}}}}}):await e.prisma.item.create({data:{...A,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:c.id,min:y,full:I}},tasks:{create:{...j,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:c.id,min:y,full:I}}}}}}),await e.pgBoss.sendAfter(S,{...c},{},E.toDate()),console.log("✔ Upserted item from event",c.summary,f==null?void 0:f.toISOString())}}),t(O,async d=>{var r,i;const a=d.data,o=await T();for(const n of Object.keys(o)){const s=await _({account:n,accountsTokens:o}),u=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${a.calendarId}`,{headers:{Authorization:`Bearer ${s.access_token}`}}).then(l=>l.json()),g=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${a.calendarId}/events?timeMin=${encodeURIComponent(e.dayjs().startOf("day").toISOString())}&timeMax=${encodeURIComponent(e.dayjs().add(a.days??7,"day").toISOString())}&singleEvents=true&orderBy=startTime`,{headers:{Authorization:`Bearer ${s.access_token}`}}).then(l=>l.json());console.log(((r=g.items)==null?void 0:r.length)??0,((i=g.items)==null?void 0:i.length)===1?"event":"events","to process from initial sync of calendar",a.calendarId);for(const l of g.items??[])await e.pgBoss.send(S,{...l,calendarColor:u.backgroundColor??null})}}),t(C,async d=>{var u,g;const a=d.data,o=await e.store.getPluginItem(m).then(l=>(l==null?void 0:l.value)??[]),r=o.find(l=>l.calendarId===a.calendarId);if(!r){console.log("❌ Could not find calendar to process",a.calendarId);return}const i=await _({account:r.account}),n=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${a.calendarId}`,{headers:{Authorization:`Bearer ${i.access_token}`}}).then(l=>l.json()),s=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${a.calendarId}/events?updatedMin=${encodeURIComponent(e.dayjs(r.lastSyncedAt).toISOString())}&singleEvents=true&orderBy=updated`,{headers:{Authorization:`Bearer ${i.access_token}`}}).then(l=>l.json());console.log(((u=s.items)==null?void 0:u.length)??0,((g=s.items)==null?void 0:g.length)===1?"event":"events","to process from webhook of calendar",a.calendarId);for(const l of s.items??[])await e.pgBoss.send(S,{...l,calendarColor:n.backgroundColor??null});await e.store.setItem(m,[...o.filter(l=>l.calendarId!==a.calendarId),{...r,lastSyncedAt:e.dayjs().toISOString()}])}),t(p,async d=>{const a=d.data;for(const o of a.calendarIds)await e.pgBoss.send(O,{calendarId:o,days:a.days??7})}),t(v,async()=>{const d=await e.getUsersTimezone(),a=e.dayjs().tz(d??void 0).endOf("day").add(1,"week");await e.prisma.task.deleteMany({where:{date:{gte:a.toDate()},pluginDatas:{some:{pluginSlug:e.pluginSlug}}}}),await e.prisma.item.deleteMany({where:{scheduledAt:{gte:a.toDate()},pluginDatas:{some:{pluginSlug:e.pluginSlug}}}})})],onUninstall:async()=>{await e.pgBoss.send(v,{}),await e.store.deleteItem(m),await e.store.deleteItem(k),await Promise.all($.map(t=>e.pgBoss.unschedule(t))),await Promise.all(x.map(t=>e.pgBoss.cancel(t)))}}});module.exports=P;
