"use strict";const U=e=>({plugin:e}),y="account-tokens",w="connected-calendars",z=U(e=>{const T=`${e.pluginSlug}-get-events`,p=`${e.pluginSlug}-calendars-sync`,S=`${e.pluginSlug}-upsert-item-from-event`,E=`${e.pluginSlug}-process-events-webhook`,_=`${e.pluginSlug}-cleanup-events`,B=`flow-${e.pluginSlug}-events-webhook-2024-05-26-1`,R=[p],P=[T,p,S,E,_],k=async()=>{const n=await e.store.getPluginItem(y);if(!n)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});return n.value},C=async n=>{const t=(n.accountsTokens??await k())[n.account];if(!t)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});if(e.dayjs().isAfter(t.expires_at)){const o=await fetch("https://google-calendar-api-flow-dev.vercel.app/api/auth/refresh?refresh_token="+t.refresh_token);if(!o.ok){const d=e.dayjs().utc(!0).startOf("day").toDate();throw await e.prisma.task.findFirst({where:{date:{gte:d},pluginDatas:{some:{originalId:"not-authenticated",pluginSlug:e.pluginSlug}}}})||await e.prisma.task.create({data:{title:'<a href="/settings/plugin/google-calendar">Re-connect</a> your Google Calendar account. There was an issue with the connection.',pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:"not-authenticated",min:{},full:{}}},day:{connectOrCreate:{where:{date:d},create:{date:d,tasksOrder:[]}}}}}),await e.pgBoss.send(_,{}),new e.GraphQLError("Could not refresh token.",{extensions:{code:"COULD_NOT_REFRESH_TOKEN",userFriendlyMessage:"Could not connect to Google Calendar. Please try connecting your account(s) again."}})}const a=await o.json(),c={...a,refresh_token:t.refresh_token,expires_at:e.dayjs().add((a.expires_in??10)-10,"seconds").toISOString()};return await e.store.setSecretItem(y,{...n.accountsTokens,[n.account]:c}),c}return t},b=async n=>{const l=await e.store.getPluginItem(w).then(t=>(t==null?void 0:t.value.map(o=>o.calendarId))??[]);return await e.pgBoss.send(p,{calendarIds:l??[],days:n.days??7}),{data:"Job sent to refresh events."}};return{onRequest:async n=>{var l,t;if(n.path==="/auth")return Response.redirect(`https://google-calendar-api-flow-dev.vercel.app/api/auth?api_endpoint=${e.serverOrigin}/api/plugin/${e.pluginSlug}/auth/callback`);if(n.path==="/auth/callback"&&n.request.method==="POST"){const o=await e.store.getPluginItem(y),a=n.body,c={...a,refresh_token:a.refresh_token??((l=o==null?void 0:o.value)==null?void 0:l[a.email].refresh_token),expires_at:e.dayjs().add((a.expires_in??10)-10,"seconds").toISOString()};return"expires_in"in c&&delete c.expires_in,await e.store.setSecretItem(y,{...(o==null?void 0:o.value)??{},[c.email]:c}),new Response}else if(n.path==="/events/webhook"&&n.request.method==="POST"){const o=n.headers["x-goog-resource-uri"],a=(t=o.match(/\/calendars\/(.*)\/events/))==null?void 0:t[1];if(!a)return console.log("❌ Could not find calendarId in x-goog-resource-uri header",o),new Response;const c=decodeURIComponent(a);return await e.pgBoss.send(E,{calendarId:c}),new Response}},operations:{calendars:async()=>{const n=await k(),l=[];for(const t of Object.keys(n)){const o=await C({account:t,accountsTokens:n}).catch(d=>({error:d}));if("error"in o){l.push({account:t,authError:o.error.extensions.userFriendlyMessage??o.error.message});continue}const a=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${o.access_token}`}}).then(d=>d.json()).then(d=>d.items),c=await e.store.getPluginItem(w).then(d=>{var s;return new Set(((s=d==null?void 0:d.value)==null?void 0:s.map(u=>u.calendarId))??[])});l.push({account:t,calendars:(a==null?void 0:a.map(d=>({...d,connected:c.has(d.id??"")})))??[]})}return{data:l}},connectCalendars:async n=>{const l=await k(),t=await e.store.getPluginItem(w).then(a=>{var c;return new Map(((c=a==null?void 0:a.value)==null?void 0:c.map(d=>[d.calendarId,d]))??[])}),o=[];for(const a of Object.keys(l)){const c=await C({account:a,accountsTokens:l}),d=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${c.access_token}`}}).then(s=>s.json()).then(s=>s.items??[]);for(const s of n.calendarIds){if(t.has(s)||!d.some(i=>i.id===s))continue;await e.pgBoss.send(T,{calendarId:s,days:7});const u=`${e.serverOrigin}/api/plugin/${e.pluginSlug}/events/webhook`;let g=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${s}/events/watch`,{method:"POST",headers:{Authorization:`Bearer ${c.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({id:B,type:"web_hook",address:u})}).then(async i=>i.ok?i.json():(console.log("❌ Failed to set up webhook for calendar",s,u,i.status,await i.text()),null));g&&(console.log("✔ Set up webhook for calendar",s,u),t.set(s,{account:a,calendarId:s,lastSyncedAt:e.dayjs().toISOString(),channelId:g.id??B,resourceId:g.resourceId,expiresAt:e.dayjs(g.expiration??0).toISOString()}))}for(const s of d){if(!s.id||n.calendarIds.includes(s.id))continue;const u=t.get(s.id);if(!u)continue;const g=await fetch("https://www.googleapis.com/calendar/v3/channels/stop",{method:"POST",headers:{Authorization:`Bearer ${c.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({resource:{id:u.channelId,resourceId:u.resourceId},id:u.channelId,resourceId:u.resourceId})});if(!g.ok){console.log("❌ Failed to remove webhook for calendar",s.id,u.channelId,u.resourceId,g.status,await g.text());continue}console.log("✔ Removed webhook for calendar",s.id),t.delete(s.id)}o.push({account:a,calendars:d.map(s=>({...s,connected:t.has(s.id??"")}))??[]})}return await e.store.setItem(w,Array.from(t.values())),await e.pgBoss.schedule(p,"0 3 */3 * *",{calendarIds:n.calendarIds}),console.log("✔ Scheduled calendars sync job"),{operationName:"calendars",data:o}},disconnectAccount:async n=>{const l=await k(),t=l[n.accountId];if(!t)return{data:"Account not connected."};const o=await e.store.getPluginItem(w).then(a=>(a==null?void 0:a.value)??[]);for(const a of o.filter(c=>c.account===n.accountId)){const c=await fetch("https://www.googleapis.com/calendar/v3/channels/stop",{method:"POST",headers:{Authorization:`Bearer ${t.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({resource:{id:a.channelId,resourceId:a.resourceId},id:a.channelId,resourceId:a.resourceId})});if(!c.ok){console.log("❌ Failed to remove webhook for calendar",a.calendarId,a.channelId,a.resourceId,c.status,await c.text());continue}console.log("✔ Removed webhook for calendar",a.calendarId)}return await e.store.setItem(w,o.filter(a=>a.account!==n.accountId)),await e.store.setItem(y,Object.fromEntries(Object.entries(l).filter(([a])=>a!==n.accountId))),{data:"Account disconnected."}},refreshEvents:b},handlePgBossWork:n=>[n(S,{batchSize:5},async l=>{var t,o,a,c,d,s,u,g;for(const i of l){const r=i.data,f=await e.prisma.item.findFirst({where:{pluginDatas:{some:{originalId:r.id,pluginSlug:e.pluginSlug}}},include:{pluginDatas:{where:{originalId:r.id,pluginSlug:e.pluginSlug},select:{id:!0}},tasks:{select:{id:!0,pluginDatas:{select:{id:!0},take:1,orderBy:{createdAt:"asc"}}},take:1,orderBy:{createdAt:"asc"}}}});if(!f&&r.status==="cancelled")continue;if(!f&&["outOfOffice","workingLocation"].includes(r.eventType??"default"))continue;const M=await e.getUsersTimezone()??"Etc/GMT-0",h=f==null?void 0:f.tasks[0],D=!!((t=r.start)!=null&&t.date),m=(o=r.start)!=null&&o.date?e.dayjs(r.start.date).startOf("day"):(a=r.start)!=null&&a.dateTime?e.dayjs(r.start.dateTime):e.dayjs(),O=(c=r.end)!=null&&c.date?e.dayjs(r.end.date).endOf("day"):(d=r.end)!=null&&d.dateTime?e.dayjs(r.end.dateTime):m.add(1,"millisecond"),N=O.isBefore(e.dayjs()),$=m.tz(M).utc(!0).toISOString(),x=r.status!=="cancelled",A={title:r.summary??"No title",color:r.calendarColor?e.getNearestItemColor(r.calendarColor):null,isAllDay:D,scheduledAt:m.toISOString(),durationInMinutes:D?null:Math.abs(e.dayjs(m).diff(O,"minute")),isRelevant:x,inboxPoints:r.status==="tentative"?10:null},I={eventType:r.eventType,status:r.status,htmlLink:r.htmlLink,numOfAttendees:((s=r.attendees)==null?void 0:s.length)??0,conferenceData:r.conferenceData,hexBackgroundColor:r.calendarColor},v={...r,...I},j={title:A.title,completedAt:N?O.toISOString():null,status:r.status==="cancelled"?"CANCELED":N?"DONE":"TODO",day:{connectOrCreate:{where:{date:$},create:{date:$,tasksOrder:h!=null&&h.id?[h.id]:[]}}}};if(f?await e.prisma.item.update({where:{id:f.id},data:{...A,pluginDatas:{update:{where:{id:(u=f.pluginDatas[0])==null?void 0:u.id},data:{min:I,full:v}}},tasks:{upsert:{where:{id:h==null?void 0:h.id},update:{...j,pluginDatas:{update:{where:{id:(g=h==null?void 0:h.pluginDatas[0])==null?void 0:g.id},data:{min:I,full:v}}}},create:{...j,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:r.id,min:I,full:v}}}}}}}):await e.prisma.item.create({data:{...A,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:r.id,min:I,full:v}},tasks:{create:{...j,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:r.id,min:I,full:v}}}}}}),console.log("✔ Upserted item from event",r.summary,m==null?void 0:m.toISOString()),!x||e.dayjs(O).isBefore(e.dayjs()))return;await e.pgBoss.sendAfter(S,{...r},{},O.add(1,"second").toDate())}}),n(T,async l=>{var a,c;const t=l.data,o=await k();for(const d of Object.keys(o)){const s=await C({account:d,accountsTokens:o}),u=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}`,{headers:{Authorization:`Bearer ${s.access_token}`}}).then(i=>i.json()),g=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}/events?timeMin=${encodeURIComponent(e.dayjs().startOf("day").toISOString())}&timeMax=${encodeURIComponent(e.dayjs().add(t.days??7,"day").toISOString())}&singleEvents=true&orderBy=startTime`,{headers:{Authorization:`Bearer ${s.access_token}`}}).then(i=>i.json());console.log(((a=g.items)==null?void 0:a.length)??0,((c=g.items)==null?void 0:c.length)===1?"event":"events","to process from initial sync of calendar",t.calendarId);for(const i of g.items??[])await e.pgBoss.send(S,{...i,calendarColor:u.backgroundColor??null})}}),n(E,async l=>{var u,g;const t=l.data,o=await e.store.getPluginItem(w).then(i=>(i==null?void 0:i.value)??[]),a=o.find(i=>i.calendarId===t.calendarId);if(!a){console.log("❌ Could not find calendar to process",t.calendarId);return}const c=await C({account:a.account}),d=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}`,{headers:{Authorization:`Bearer ${c.access_token}`}}).then(i=>i.json()),s=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${t.calendarId}/events?updatedMin=${encodeURIComponent(e.dayjs(a.lastSyncedAt).toISOString())}&singleEvents=true&orderBy=updated`,{headers:{Authorization:`Bearer ${c.access_token}`}}).then(i=>i.json());console.log(((u=s.items)==null?void 0:u.length)??0,((g=s.items)==null?void 0:g.length)===1?"event":"events","to process from webhook of calendar",t.calendarId);for(const i of s.items??[])await e.pgBoss.send(S,{...i,calendarColor:d.backgroundColor??null});await e.store.setItem(w,[...o.filter(i=>i.calendarId!==t.calendarId),{...a,lastSyncedAt:e.dayjs().toISOString()}])}),n(p,async l=>{const t=l.data;for(const o of t.calendarIds)await e.pgBoss.send(T,{calendarId:o,days:t.days??7})}),n(_,async()=>{const l=await e.getUsersTimezone(),t=e.dayjs().tz(l??void 0).endOf("day").add(1,"week");await e.prisma.task.deleteMany({where:{date:{gte:t.toDate()},pluginDatas:{some:{pluginSlug:e.pluginSlug}}}}),await e.prisma.item.deleteMany({where:{scheduledAt:{gte:t.toDate()},pluginDatas:{some:{pluginSlug:e.pluginSlug}}}})})],onUninstall:async()=>{await e.pgBoss.send(_,{}),await e.store.deleteItem(w),await e.store.deleteItem(y),await Promise.all(R.map(n=>e.pgBoss.unschedule(n))),await Promise.all(P.map(n=>e.pgBoss.cancel(n)))},onRefreshCalendarItems:async()=>{await b({days:7})}}});module.exports=z;
