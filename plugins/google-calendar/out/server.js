"use strict";const U=e=>({plugin:e}),m="account-tokens",g="connected-calendars",p="default-calendar-id",P=U(e=>{const v=`${e.pluginSlug}-get-events`,w=`${e.pluginSlug}-calendars-sync`,f=`${e.pluginSlug}-upsert-item-from-event`,k=`${e.pluginSlug}-process-events-webhook`,S=`${e.pluginSlug}-cleanup-events`,C=`flow-${e.pluginSlug}-events-webhook-2024-05-26-1`,N=[w],$=[v,w,f,k,S],I=async()=>{const a=await e.store.getPluginItem(m);if(!a)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});return a.value},y=async a=>{const n=(a.accountsTokens??await I())[a.account];if(!n)throw new e.GraphQLError("User not authenticated.",{extensions:{code:"NOT_AUTHENTICATED",userFriendlyMessage:"You are not authenticated and will need to connect your Google account first."}});if(e.dayjs().isAfter(n.expires_at)){const o=await fetch("https://google-calendar-api-flow-dev.vercel.app/api/auth/refresh?refresh_token="+n.refresh_token);if(!o.ok){const s=e.dayjs().utc(!0).startOf("day").toDate();throw await e.prisma.task.findFirst({where:{date:{gte:s},pluginDatas:{some:{originalId:"not-authenticated",pluginSlug:e.pluginSlug}}}})||await e.prisma.task.create({data:{title:'<a href="/settings/plugin/google-calendar">Reconnect</a> your Google Calendar account. There was an issue with the connection.',pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:"not-authenticated",min:{},full:{}}},day:{connectOrCreate:{where:{date:s},create:{date:s,tasksOrder:[]}}}}}),await e.pgBoss.send(S,{}),new e.GraphQLError("Could not refresh token.",{extensions:{code:"COULD_NOT_REFRESH_TOKEN",userFriendlyMessage:"Could not connect to Google Calendar. Please try connecting your account(s) again."}})}const t=await o.json(),r={...t,refresh_token:n.refresh_token,expires_at:e.dayjs().add((t.expires_in??10)-10,"seconds").toISOString()};return await e.store.setSecretItem(m,{...a.accountsTokens,[a.account]:r}),r}return n},O=async a=>{const u=await e.store.getPluginItem(g).then(n=>(n==null?void 0:n.value.map(o=>o.calendarId))??[]);return await e.pgBoss.send(w,{calendarIds:u??[],days:a.days??7}),{data:"Job sent to refresh events."}},A=async a=>{var T,_,E,B,j,D,b;const u=await e.getUsersTimezone()??"Etc/GMT-0",n=!!((T=a.event.start)!=null&&T.date),o=(_=a.event.start)!=null&&_.date?e.dayjs(a.event.start.date).startOf("day"):(E=a.event.start)!=null&&E.dateTime?e.dayjs(a.event.start.dateTime):e.dayjs(),t=(B=a.event.end)!=null&&B.date?e.dayjs(a.event.end.date).endOf("day"):(j=a.event.end)!=null&&j.dateTime?e.dayjs(a.event.end.dateTime):o.add(1,"millisecond"),r=t.isBefore(e.dayjs()),s=o.tz(u).utc(!0).toISOString(),l=a.event.status!=="cancelled",c={title:a.event.summary??"No title",color:a.event.calendarColor?e.getNearestItemColor(a.event.calendarColor):null,isAllDay:!!((D=a.event.start)!=null&&D.date),scheduledAt:o.toISOString(),durationInMinutes:n?null:Math.abs(e.dayjs(o).diff(t,"minute")),isRelevant:l,inboxPoints:a.event.status==="tentative"?10:null},d={eventType:a.event.eventType,status:a.event.status,htmlLink:a.event.htmlLink,numOfAttendees:((b=a.event.attendees)==null?void 0:b.length)??0,conferenceData:a.event.conferenceData,hexBackgroundColor:a.event.calendarColor},i={...a.event,...d},h={title:c.title,completedAt:r?t.toISOString():null,status:a.event.status==="cancelled"?"CANCELED":r?"DONE":"TODO",day:{connectOrCreate:{where:{date:s},create:{date:s,tasksOrder:a.taskId?[a.taskId]:[]}}}};return{itemInfo:{commonBetweenUpdateAndCreate:c,min:d,full:i,isRelevant:l,scheduledStart:o,scheduledEnd:t},taskInfo:{commonBetweenUpdateAndCreate:h,min:d,full:i}}};return{onRequest:async a=>{var u,n;if(a.path==="/auth")return Response.redirect(`https://google-calendar-api-flow-dev.vercel.app/api/auth?api_endpoint=${e.serverOrigin}/api/plugin/${e.pluginSlug}/auth/callback`);if(a.path==="/auth/callback"&&a.request.method==="POST"){const o=await e.store.getPluginItem(m),t=a.body,r={...t,refresh_token:t.refresh_token??((u=o==null?void 0:o.value)==null?void 0:u[t.email].refresh_token),expires_at:e.dayjs().add((t.expires_in??10)-10,"seconds").toISOString()};return"expires_in"in r&&delete r.expires_in,await e.store.setSecretItem(m,{...(o==null?void 0:o.value)??{},[r.email]:r}),new Response}else if(a.path==="/events/webhook"&&a.request.method==="POST"){const o=a.headers["x-goog-resource-uri"],t=(n=o.match(/\/calendars\/(.*)\/events/))==null?void 0:n[1];if(!t)return console.log("âŒ Could not find calendarId in x-goog-resource-uri header",o),new Response;const r=decodeURIComponent(t);return await e.pgBoss.send(k,{calendarId:r}),new Response}},operations:{calendars:async()=>{const a=await I(),u=[];for(const n of Object.keys(a)){const o=await y({account:n,accountsTokens:a}).catch(s=>({error:s}));if("error"in o){u.push({account:n,authError:o.error.extensions.userFriendlyMessage??o.error.message});continue}const t=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${o.access_token}`}}).then(s=>s.json()).then(s=>s.items),r=await e.store.getPluginItem(g).then(s=>{var l;return new Set(((l=s==null?void 0:s.value)==null?void 0:l.map(c=>c.calendarId))??[])});u.push({account:n,calendars:(t==null?void 0:t.map(s=>({...s,connected:r.has(s.id??"")})))??[]})}return{data:u}},connectCalendars:async a=>{const u=await I();let n=await e.store.getPluginItem(p).then(r=>r==null?void 0:r.value);const o=await e.store.getPluginItem(g).then(r=>{var s;return new Map(((s=r==null?void 0:r.value)==null?void 0:s.map(l=>[l.calendarId,l]))??[])}),t=[];for(const r of Object.keys(u)){const s=await y({account:r,accountsTokens:u}),l=await fetch("https://www.googleapis.com/calendar/v3/users/me/calendarList",{headers:{Authorization:`Bearer ${s.access_token}`}}).then(c=>c.json()).then(c=>c.items??[]);for(const c of a.calendarIds){if(o.has(c)||!l.some(h=>h.id===c))continue;await e.pgBoss.send(v,{calendarId:c,days:7});const d=`${e.serverOrigin}/api/plugin/${e.pluginSlug}/events/webhook`;let i=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${c}/events/watch`,{method:"POST",headers:{Authorization:`Bearer ${s.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({id:C,type:"web_hook",address:d})}).then(async h=>h.ok?h.json():(console.log("âŒ Failed to set up webhook for calendar",c,d,h.status,await h.text()),null));i&&(console.log("âœ” Set up webhook for calendar",c,d),n||(n={account:r,id:c}),o.set(c,{account:r,calendarId:c,lastSyncedAt:e.dayjs().toISOString(),channelId:i.id??C,resourceId:i.resourceId,expiresAt:e.dayjs(i.expiration??0).toISOString(),default:(n==null?void 0:n.id)===c}))}for(const c of l){if(!c.id||a.calendarIds.includes(c.id))continue;const d=o.get(c.id);if(!d)continue;const i=await fetch("https://www.googleapis.com/calendar/v3/channels/stop",{method:"POST",headers:{Authorization:`Bearer ${s.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({resource:{id:d.channelId,resourceId:d.resourceId},id:d.channelId,resourceId:d.resourceId})});if(!i.ok){console.log("âŒ Failed to remove webhook for calendar",c.id,d.channelId,d.resourceId,i.status,await i.text());continue}console.log("âœ” Removed webhook for calendar",c.id),o.delete(c.id)}t.push({account:r,calendars:l.map(c=>({...c,connected:o.has(c.id??"")}))??[]})}return await e.store.setItem(g,Array.from(o.values())),n&&await e.store.setItem(p,n),await e.pgBoss.schedule(w,"0 3 */3 * *",{calendarIds:a.calendarIds}),console.log("âœ” Scheduled calendars sync job"),{operationName:"calendars",data:t}},disconnectAccount:async a=>{const u=await I(),n=u[a.accountId];if(!n)return{data:"Account not connected."};const o=await e.store.getPluginItem(g).then(t=>(t==null?void 0:t.value)??[]);for(const t of o.filter(r=>r.account===a.accountId)){const r=await fetch("https://www.googleapis.com/calendar/v3/channels/stop",{method:"POST",headers:{Authorization:`Bearer ${n.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({resource:{id:t.channelId,resourceId:t.resourceId},id:t.channelId,resourceId:t.resourceId})});if(!r.ok){console.log("âŒ Failed to remove webhook for calendar",t.calendarId,t.channelId,t.resourceId,r.status,await r.text());continue}console.log("âœ” Removed webhook for calendar",t.calendarId)}return await e.store.setItem(g,o.filter(t=>t.account!==a.accountId)),await e.store.setItem(m,Object.fromEntries(Object.entries(u).filter(([t])=>t!==a.accountId))),{data:"Account disconnected."}},refreshEvents:O},handlePgBossWork:a=>[a(f,{batchSize:5},async u=>{var n,o,t;for(const r of u){const s=r.data,l=await e.prisma.item.findFirst({where:{pluginDatas:{some:{originalId:s.id,pluginSlug:e.pluginSlug}}},include:{pluginDatas:{where:{originalId:s.id,pluginSlug:e.pluginSlug},select:{id:!0}},tasks:{select:{id:!0,pluginDatas:{select:{id:!0},take:1,orderBy:{createdAt:"asc"}}},take:1,orderBy:{createdAt:"asc"}}}});if(!l&&s.status==="cancelled")continue;if(!l&&["outOfOffice","workingLocation"].includes(s.eventType??"default"))continue;if(!s.summary||s.summary.trim()==="")if(l)s.summary=l.title;else continue;const c=l==null?void 0:l.tasks[0],{itemInfo:d,taskInfo:i}=await A({event:s,taskId:c==null?void 0:c.id});if(l?await e.prisma.item.update({where:{id:l.id},data:{...d.commonBetweenUpdateAndCreate,pluginDatas:{update:{where:{id:(n=l.pluginDatas[0])==null?void 0:n.id},data:{min:d.min,full:d.full}}},tasks:{upsert:{where:{id:c==null?void 0:c.id},update:{...i.commonBetweenUpdateAndCreate,pluginDatas:{update:{where:{id:(o=c==null?void 0:c.pluginDatas[0])==null?void 0:o.id},data:{min:i.min,full:i.full}}}},create:{...i.commonBetweenUpdateAndCreate,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:s.id,min:i.min,full:i.full}}}}}}}):await e.prisma.item.create({data:{...d.commonBetweenUpdateAndCreate,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:s.id,min:d.min,full:d.full}},tasks:{create:{...i.commonBetweenUpdateAndCreate,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:s.id,min:i.min,full:i.full}}}}}}),console.log("âœ” Upserted item from event",s.summary,(t=d.scheduledStart)==null?void 0:t.toISOString()),!d.isRelevant||e.dayjs(d.scheduledEnd).isBefore(e.dayjs()))return;await e.pgBoss.sendAfter(f,{...s},{},d.scheduledEnd.add(1,"second").toDate())}}),a(v,async u=>{var t,r;const n=u.data,o=await I();for(const s of Object.keys(o)){const l=await y({account:s,accountsTokens:o}),c=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${n.calendarId}`,{headers:{Authorization:`Bearer ${l.access_token}`}}).then(i=>i.json()),d=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${n.calendarId}/events?timeMin=${encodeURIComponent(e.dayjs().startOf("day").toISOString())}&timeMax=${encodeURIComponent(e.dayjs().add(n.days??7,"day").toISOString())}&singleEvents=true&orderBy=startTime`,{headers:{Authorization:`Bearer ${l.access_token}`}}).then(i=>i.json());console.log(((t=d.items)==null?void 0:t.length)??0,((r=d.items)==null?void 0:r.length)===1?"event":"events","to process from initial sync of calendar",n.calendarId);for(const i of d.items??[])await e.pgBoss.send(f,{...i,calendarColor:c.backgroundColor??null})}}),a(k,async u=>{var c,d;const n=u.data,o=await e.store.getPluginItem(g).then(i=>(i==null?void 0:i.value)??[]),t=o.find(i=>i.calendarId===n.calendarId);if(!t){console.log("âŒ Could not find calendar to process",n.calendarId);return}const r=await y({account:t.account}),s=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${n.calendarId}`,{headers:{Authorization:`Bearer ${r.access_token}`}}).then(i=>i.json()),l=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${n.calendarId}/events?updatedMin=${encodeURIComponent(e.dayjs(t.lastSyncedAt).toISOString())}&singleEvents=true&orderBy=updated`,{headers:{Authorization:`Bearer ${r.access_token}`}}).then(i=>i.json());console.log(((c=l.items)==null?void 0:c.length)??0,((d=l.items)==null?void 0:d.length)===1?"event":"events","to process from webhook of calendar",n.calendarId);for(const i of l.items??[])await e.pgBoss.send(f,{...i,calendarColor:s.backgroundColor??null});await e.store.setItem(g,[...o.filter(i=>i.calendarId!==n.calendarId),{...t,lastSyncedAt:e.dayjs().toISOString()}])}),a(w,async u=>{const n=u.data;for(const o of n.calendarIds)await e.pgBoss.send(v,{calendarId:o,days:n.days??7})}),a(S,async()=>{const u=await e.getUsersTimezone(),n=e.dayjs().tz(u??void 0).endOf("day").add(1,"week");await e.prisma.task.deleteMany({where:{date:{gte:n.toDate()},pluginDatas:{some:{pluginSlug:e.pluginSlug}}}}),await e.prisma.item.deleteMany({where:{scheduledAt:{gte:n.toDate()},pluginDatas:{some:{pluginSlug:e.pluginSlug}}}})})],onUninstall:async()=>{await e.pgBoss.send(S,{}),await e.store.deleteItem(g),await e.store.deleteItem(m),await Promise.all(N.map(a=>e.pgBoss.unschedule(a))),await Promise.all($.map(a=>e.pgBoss.cancel(a)))},onCreateCalendarItem:async({item:a})=>{var c;const u=await e.store.getPluginItem(p).then(d=>d==null?void 0:d.value);if(!u)return;const n=await y({account:u.account}),o=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${u.id}`,{headers:{Authorization:`Bearer ${n.access_token}`}}).then(d=>d.json());console.log("ðŸ“… Creating Google calendar event from Flow item",a.id);let t=await fetch(`https://www.googleapis.com/calendar/v3/calendars/${u.id}/events`,{method:"POST",headers:{Authorization:`Bearer ${n.access_token}`,"Content-Type":"application/json"},body:JSON.stringify({summary:a.title,start:{dateTime:e.dayjs(a.scheduledAt).toISOString()},end:{dateTime:e.dayjs(a.scheduledAt).add(a.durationInMinutes??30,"minute").toISOString()}})}).then(d=>d.json());if(!t)return;console.log("âœ” Created event in Google Calendar",u.id,t.id),t={...t,calendarColor:o.backgroundColor??null};const r=(c=a.tasks[0])==null?void 0:c.id,{itemInfo:s,taskInfo:l}=await A({event:t,taskId:r});await e.prisma.item.update({where:{id:a.id},data:{...s.commonBetweenUpdateAndCreate,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:t.id,min:s.min,full:s.full}}}}),await e.prisma.task.update({where:{id:r},data:{...l.commonBetweenUpdateAndCreate,pluginDatas:{create:{pluginSlug:e.pluginSlug,originalId:t.id,min:l.min,full:l.full}}}})},onRefreshCalendarItems:async()=>{await O({days:7})}}});module.exports=P;
